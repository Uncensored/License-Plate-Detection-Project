#include <opencv2/core/core.hpp>#include <opencv2/imgproc/imgproc.hpp>#include <opencv2/highgui/highgui.hpp>#include <iostream>#include <string>#include <cmath>#include <limits>using namespace cv;using namespace std;vector<Rect> sizeFilter ( Mat gray )	{	int c = gray.cols;	int r = gray.rows;	vector<Rect> ROI;	Mat blur;	GaussianBlur ( gray, blur, Size ( 21, 21 ), 5 );	Mat BIN;	threshold ( blur, BIN, 0, 255, THRESH_BINARY + THRESH_OTSU );	Mat Label, stats, centroids;	int numLabel = connectedComponentsWithStats ( BIN, Label, stats, centroids, 8, CV_32S );	for ( int i = 0; i < numLabel; i++ ) {			int x = stats.at<int> ( i, CC_STAT_LEFT );			int y = stats.at<int> ( i, CC_STAT_TOP );			int w = stats.at<int> ( i, CC_STAT_WIDTH );			int h = stats.at<int> ( i, CC_STAT_HEIGHT );			int a = w * h;			int p = ( w + h ) * 2;			float ratio_wh = ( float ) w / ( float ) h;			float ratio_ap = ( float ) a / ( float ) p;			if ( w > c / 15 && w < c / 3 && h > r / 15 && h < r / 3 && ratio_wh > 1.5 && ratio_wh < 3 && ratio_ap > 15 ) {					ROI.push_back ( Rect ( x, y, w, h ) );					}			}	return ROI;	}float CalSD ( vector<int> data )	{	float sum = 0.0, mean = 0.0, SD = 0.0;	int sizeOfData = data.size();	for ( int i = 0; i < sizeOfData; i++ ) {			sum += data[i];			}	mean = sum / sizeOfData;	for ( int i = 0; i < sizeOfData; i++ ) {			SD += pow ( data[i] - mean, 2 );			}	return sqrt ( SD / sizeOfData );	}Rect numFilter ( Mat gray, vector<Rect> ROI )	{	int sizeOfROI = ROI.size();	if ( sizeOfROI == 0 ) {			return Rect ( gray.cols / 2, gray.rows / 2, 35, 15 );			}	else		if ( sizeOfROI == 1 ) {				return ROI[0];				}		else {				float idx = 0, MIN = numeric_limits<float>::infinity();				for ( int i = 0; i < sizeOfROI; i++ ) {						Mat crop = Mat ( gray, ROI[i] );						GaussianBlur ( crop, crop, Size ( 13, 13 ), 3 );						threshold ( crop, crop, 0, 255, THRESH_BINARY + THRESH_OTSU );						crop = 255 - crop;						Mat Label, stats, centroids;						int numLabel = connectedComponentsWithStats ( crop, Label, stats, centroids, 8, CV_32S );						vector<int> data;						for ( int j = 0; j < numLabel; j++ ) {								int x = stats.at<int> ( j, CC_STAT_LEFT );								int y = stats.at<int> ( j, CC_STAT_TOP );								int w = stats.at<int> ( j, CC_STAT_WIDTH );								int h = stats.at<int> ( j, CC_STAT_HEIGHT );								float ratio_wh = ( float ) w / ( float ) h;								if ( w > ( crop.cols / 13 ) && w < ( crop.cols / 5 ) && h > ( crop.rows / 5 ) && h < ( crop.rows / 1.7 ) && ratio_wh < 0.8 && ratio_wh > 0.5 ) {										rectangle ( crop, Rect ( x, y, w, h ), Scalar ( 128 ), 3 );										data.push_back ( y );										}								}						if ( data.size() >= 3 ) {								float SD = CalSD ( data );								if ( SD < MIN ) {										MIN = SD;										idx = i;										}								}						}				return ROI[idx];				}	}Mat findLP ( Mat img )	{	Mat gray;	cvtColor ( img, gray, CV_BGR2GRAY );	equalizeHist ( gray, gray );	vector<Rect> a_sizeFilter = sizeFilter ( gray ) ;	Rect result =  numFilter ( gray, a_sizeFilter);	Mat LP = Mat ( img, result );		rectangle(img,result,Scalar(0,255,0),3);	imwrite("result/cover.jpg",img);	return LP;	}int main ( int argc, char *argv[] )	{	//    vector<String> fn;	//    glob("testSubset/*.jpg",fn,false);	//	//	//    for(int i = 0;i < fn.size();i++){	//	//        Mat img = imread(fn[i], CV_LOAD_IMAGE_COLOR);	//	//        namedWindow("result",WINDOW_KEEPRATIO);	//        resizeWindow("result",1366,768);	//        findLP(img);	//	//        waitKey(0);	//        destroyAllWindows();	//	//    }	Mat img = imread ( "testSubset/20140317_084202.jpg", CV_LOAD_IMAGE_COLOR );	namedWindow ( "result", WINDOW_KEEPRATIO );	resizeWindow ( "result", 1366, 768 );		imshow ( "result",  );	imwrite("result/cover.jpg",img);	waitKey ( 0 );	destroyAllWindows();	return 0;	}